<!DOCTYPE html><html lang=en> <head><meta charset=UTF-8><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=generator content="Asciidoctor 1.5.8"><title>Zadania z biblioteczkami considered harmful</title><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"><link rel=stylesheet href=./asciidoctor.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=./coderay-asciidoctor.css><link rel="shortcut icon" type=image/x-icon href=/favicon.ico></head> <body class=article> <div id=header> <h1>Zadania z biblioteczkami considered harmful</h1> <div class=details> <span id=revdate>2019-04-11</span> </div> </div> <div id=content> <div id=preamble> <div class=sectionbody> <div class="admonitionblock warning"> <table> <tr> <td class=icon> <i class="fa icon-warning" title=Warning></i> </td> <td class=content> Moje poglądy trochę się zmieniły od kiedy to napisałem; stwierdziłem że w praktyce okazjonalna dyskwalifikacja jak ktoś zrobi coś nie tak jest mniejszym nakładem pracy niż przeprojektowanie całego systemu żeby był odporny (zwłaszcza, że organizatorzy i tak muszą przejrzeć wszystkie zgłoszenia). Poza tym można napisać własną wersję biblioteczki która i tak wszystko wczytuje i wypisuje na standardowe strumienie. Więc chociaż biblioteczki nadal są w mojej opinii trochę gorszym rozwiązaniem, nie są aż tak złe żebym nadal był inkwizytorem alternatywnych rozwiązań. </td> </tr> </table> </div> <div class="imageblock left"> <div class=content> <img src=https://sio2.mimuw.edu.pl/static/oi/logo.png alt=logo> </div> <div class=title>Establishment</div> </div> <div class=paragraph> <p>Powszechnie wiadomo, że Olimpiada Informatyczna, ściągając formułę konkursu od LOGII, nieświadomie zepsuła tradycyjną sztukę mierzenia talentu programistycznego na kilka ważnych sposobów. Są to oczywistości takie jak absurdalnie małe limity czasowe (żeby przyoszczędzić na czasie serwera przy sprawdzaniu rozwiązań), ale są to też rzeczy, o których niektórzy mogą nawet nigdy krytycznie nie pomyśleć&#8201;&#8212;&#8201;mam na myśli zadania z biblioteczkami.</p> </div> <div class=paragraph> <p>Ponieważ <em>każde</em> warsztaty i <em>każdy</em> obóz informatyczny jaki znam przygotowują ostatecznie do Olimpiady, gdzie mogą wystąpić takie zadania, <em>wszędzie</em> są takie zadania, "dla naszego własnego dobra, żebyśmy byli przygotowani".</p> </div> <div class=paragraph> <p>Łatwo je zaakceptować jako coś naturalnego, nauczyć się ich używać, pogodzić się ze wszystkimi wadami i mieć po prostu nadzieję, że będą się pojawiać jak najrzadziej. To jest jednak dokładnie podejście, jakiego oczekują od nas ludzie mający sekretny interes w utrzymywaniu tej szkodliwej tradycji&#8201;&#8212;&#8201;naszym obowiązkiem wobec przyszłych pokoleń jest się im sprzeciwić.</p> </div> </div> </div> <div class=sect2> <h3 id=_zrozumieć>Zrozumieć</h3> <div class=paragraph> <p>Sam koncept biblioteczek wydaje się prosty, intuicyjny i genialny: dzięki temu, że program musi wywoływać nasze funkcje, może tylko na bieżąco odpowiadać na zapytania, więc można przyznawać punkty tylko algorytmom online! Hurra! Kolejny problem, który występowałby rzadziej gdybyśmy nie mieli na niego rozwiązania, rozwiązany!</p> </div> </div> <div class=sect1> <h2 id=_jednak>Jednak:</h2> <div class=sectionbody> <div class=sect2> <h3 id=_wydłużanie_treści_zadania>Wydłużanie treści zadania</h3> <div class=paragraph> <p>Chociaż dodanie jednego pliku do kompilacji może wydawać się proste dla doświadczonych osób, nie wszystkie osoby są doświadczone. Aby nie ustawiać zawodów przeciwko nim, w każdym zadaniu musi być wyjaśnione: skąd wziąć przykładową biblioteczkę, gdzie jest przykładowe błędne rozwiązanie, jak to skompilować, jak to testować, jakie są dokładne typy deklaracji funkcji.</p> </div> <div class=paragraph> <p>W ten sposób na OI 30-70% treści każdego zadania z biblioteczką to nudne, czysto techniczne wyjaśnienia niezwiązane z treścią zadania ani algorytmiką.</p> </div> </div> <div class=sect2> <h3 id=_narzucanie_konwencji>Narzucanie konwencji</h3> <div class=paragraph> <p>W zadaniach muszą być podane dokładne interfejsy komunikacji z rozwiązaniem. Jedynym osiągnięciem wymuszania użycia w jednym zadaniu <code>long long WartoscNaPozycji()</code> a w innym <code>int value_at_pos()</code> jest zmniejszenie czytelności i walorów estetycznych kodu.</p> </div> </div> <div class=sect2> <h3 id=_bezpieczeństwo>Bezpieczeństwo</h3> <div class=paragraph> <p>Możemy chyba się zgodzić, że bezpieczeństwo nie jest mocną stroną języka C++. Korupcja stosu to jedna z podstawowych operacji. Konstruktory obiektów klas globalnych wywołują się przed funkcją <code>main()</code>, więc naiwne zablokowanie tej funkcji w biblioteczce w niczym nie pomaga.</p> </div> <div class=paragraph> <p>Python z kolei nawet nie ukrywa, że wszystko jest możliwe z odpowiednim modułem. Funkcja <code>globals()</code> zwracająca wszystkie funkcje globalne jest wbudowana. Moduł <code>ast</code> służy do wygodnej modyfikacji kodu w czasie wykonywania.</p> </div> <div class=paragraph> <p>Jedyne co chroni kontesty przed masowym hakowaniem sprawdzarek w taki sposób to utrzymywanie ich kodów źródłowych w tajemnicy. Nazywamy to <em>security by obscurity</em> i jest to niebezpieczny stan rzeczy: jeden wyciek kodu źródłowego i wszystkie podobnie zaimplementowane sprawdzarki nagle są podatne na ataki.</p> </div> <div class=paragraph> <p>Sprawia to oczywiście, że nie znam ani jednego przypadku gdy sprawdzarka została publicznie udostępniona, nawet gdy same pliki z testami były.</p> </div> <div class=exampleblock> <div class=content> <div class=paragraph> <p>Na XXVI Olimpiadzie Informatycznej w zadaniu oczekującym, że rozwiązanie wywoła <code>give_answer(n)</code>, pewien uczestnik w Pythonie zwrócił mniej-więcej taki obiekt:</p> </div> <div class=listingblock> <div class=content> <pre class="CodeRay highlight"><code data-lang=python><span class=keyword>class</span> <span class=class>X</span>(<span class=predefined>int</span>):
    <span class=keyword>def</span> <span class=function>__eq__</span>(<span class=predefined-constant>self</span>, other):
        <span class=keyword>return</span> other != <span class=integer>0</span>
    <span class=keyword>def</span> <span class=function>__int__</span>(<span class=predefined-constant>self</span>):
        <span class=keyword>return</span> <span class=predefined-constant>self</span>
give_answer(X())</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class=icon> <i class="fa icon-note" title=Note></i> </td> <td class=content> Dla osób niepłynnych w Pythonie: porównanie obiektu klasy X z dowolną liczbą nierówną zeru zwraca wartość prawdziwą. Dodatkowo, próba zamiany takiego obiektu na zwykłą liczbę całkowitą używając funkcji <code>int()</code> jest bezskuteczna (w Pythonie 3.4 używanym wtedy na olimpiadzie&#8201;&#8212;&#8201;zostało to naprawione w nowszych wersjach). </td> </tr> </table> </div> <div class=paragraph> <p>Jak zauważył pewien anonimowy algorytmik, jest to jedyny udokumentowany przypadek wykorzystania polimorfizmu na Olimpiadzie Informatycznej.</p> </div> <div class=paragraph> <p>Prawdopodobnie jednak większość biblioteczek jest zabezpieczona tak, że program sprawdzający wypisuje jakiś hasz wejścia oraz odpowiedzi zwrócone przez program, co znacznie utrudnia hakowanie.</p> </div> </div> </div> <div class=paragraph> <p>Oczywiście, takie ataki przestają działać w momencie gdy ktoś zajrzy do kodu, czyli z personalnego doświadczenia przed 20:00 tego samego dnia. Większość osób to wie i nawet nie próbuje marnować swojego czasu.</p> </div> <div class=paragraph> <p>Można też założyć, że większość ludzi jest uczciwa i nie wykorzysta żadnej oczywistej dziury w systemie w celu zdobycia przewagi. Taki sposób myślenia sprawia tylko, że będziemy zaskoczeni gdy nieuchronnie się znajdzie wyjątek.</p> </div> </div> </div> </div> <div class=sect1> <h2 id=_lepsza_alternatywa>Lepsza alternatywa</h2> <div class=sectionbody> <div class=paragraph> <p>Więc, mając nadzieję, że przekonałem wszystkich zwolenników starego systemu, przedstawię teraz alternatywę. Nie jest to całkowita likwidacja zadań domagających się rozwiązań online&#8201;&#8212;&#8201;to bardzo ciekawa grupa algorytmów.</p> </div> <div class=paragraph> <p>Wszyscy wiemy, że wejście i wyjście zarówno w Pythonie jak i C++ jest <em>asynchroniczne</em>. I to jest właśnie problemem gdy chcemy algorytm działający online&#8201;&#8212;&#8201;nic nie powstrzymuje rozwiązania przed wczytaniem wszystkich zapytań i odpowiedzeniem na wszystkie naraz.</p> </div> <div class=paragraph> <p>Hmm&#8230;&#8203; jak można rozwiązać ten problem?</p> </div> <div class=quoteblock> <blockquote> <div class=paragraph> <p>Wiem: sprawię że wszyscy się będą męczyć z dodatkowymi nagłówkami i ich kompilacją, narzucę im mój styl nazywania funkcji, a do tego wszystkiego nawet nie załatam oczywistych dziur w bezpieczeństwie i po prostu cicho zdyskwalifikuję każdego kto jakąś znajdzie!</p> </div> </blockquote> <div class=attribution> &#8212; Ktoś najwyraźniej wpływowy<br> <cite>dzień przed wprowadzeniem zadań z biblioteczkami</cite> </div> </div> <div class=paragraph> <p>Nie.</p> </div> <div class=paragraph> <p>Otóż rozwiązaniem jest <em>synchroniczne</em> wejście i wyjście. Po prostu kazać rozwiązaniu uczestnika flushować odpowiedź po każdym zapytaniu i nie przesyłać kolejnego wiersza wejścia jeżeli nie dostanie się odpowiedzi. Wszystko przez bezpieczny, znany i przyjazny strumień tekstowy, niemożliwy do zhackowania.</p> </div> <div class=paragraph> <p>Okazuje się, że jest to system od dawna szczęśliwie używany przez Codeforces.</p> </div> </div> </div> </div> </body> </html>